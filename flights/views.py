from django.http import JsonResponse
from django.utils import timezone
from django.conf import settings
from datetime import datetime
from airports.models import Airport
from airports.services import AirportCacheService
import urllib.request
import urllib.parse
import base64
import json
import math
import logging

logger = logging.getLogger(__name__)

def flight_search(request):
    """Search for round-trip flights between two airports."""
    logger.debug(f"Received request with params: {request.GET}")
    
    try:
        validation_result = validate_request_params(request)
        if validation_result:
            return validation_result
        
        origin_airport, dest_airport = load_airports(
            request.GET.get('origin').upper(),
            request.GET.get('destination').upper()
        )
        if not origin_airport or not dest_airport:
            return JsonResponse({'error': 'Invalid airport codes'}, status=400)
        
        combinations = search_flight_combinations(
            origin_airport, 
            dest_airport,
            request.GET.get('departure_date'),
            request.GET.get('return_date')
        )
        
        response = build_response(
            origin_airport, 
            dest_airport, 
            combinations,
            request.GET.get('departure_date'),
            request.GET.get('return_date')
        )
        
        return JsonResponse(response)
    
    except Exception as e:
        logger.error(f"Error in flight_search: {str(e)}", exc_info=True)
        return JsonResponse({'error': 'Internal server error'}, status=500)


def validate_request_params(request):
    origin = request.GET.get('origin')
    destination = request.GET.get('destination')
    departure_date_str = request.GET.get('departure_date')
    return_date_str = request.GET.get('return_date')
    
    if not all([origin, destination, departure_date_str, return_date_str]):
        logger.error("Missing parameters")
        return JsonResponse({'error': 'Missing parameters'}, status=400)
    
    origin = origin.upper()
    destination = destination.upper()
    
    if origin == destination:
        logger.error("Origin and destination cannot be the same")
        return JsonResponse({'error': 'Origin and destination cannot be the same'}, status=400)
    
    try:
        dep_date = datetime.strptime(departure_date_str, '%Y-%m-%d').date()
        ret_date = datetime.strptime(return_date_str, '%Y-%m-%d').date()
        today = timezone.now().date()
        
        if dep_date < today or ret_date < dep_date:
            logger.error("Invalid dates")
            return JsonResponse({'error': 'Invalid dates'}, status=400)
    except ValueError:
        logger.error("Invalid date format")
        return JsonResponse({'error': 'Invalid date format (use YYYY-MM-DD)'}, status=400)
    
    return None


def load_airports(origin_iata, destination_iata):
    """Load airports from cache and create Airport instances."""
    cache_service = AirportCacheService()
    
    origin_data = cache_service.get_airport_by_iata(origin_iata)
    if not origin_data:
        logger.error(f"Invalid airport code: origin={origin_iata}")
        return None, None
    
    dest_data = cache_service.get_airport_by_iata(destination_iata)
    if not dest_data:
        logger.error(f"Invalid airport code: destination={destination_iata}")
        return None, None
    
    origin_airport = create_airport_from_cache(origin_data)
    dest_airport = create_airport_from_cache(dest_data)
    
    return origin_airport, dest_airport


def create_airport_from_cache(cache_data):
    return Airport(
        iata=cache_data['iata'],
        city=cache_data['city'],
        lat=cache_data['lat'],
        lon=cache_data['lon'],
        state=cache_data['state']
    )

# Calculation generated by Grok AI:
def search_flight_combinations(origin_airport, dest_airport, departure_date_str, return_date_str):
    """Search and combine flights."""
    # Calculate distance once
    distance = haversine(
        origin_airport.lat, origin_airport.lon, 
        dest_airport.lat, dest_airport.lon
    )
    
    # Get flight options
    outbound_data = call_mock_api(origin_airport.iata, dest_airport.iata, departure_date_str)
    return_data = call_mock_api(dest_airport.iata, origin_airport.iata, return_date_str)
    
    outbound_options = outbound_data['options']
    return_options = return_data['options']
    
    # Process flight options
    process_flight_options(outbound_options, distance)
    process_flight_options(return_options, distance)
    
    # Create combinations
    combinations = create_flight_combinations(outbound_options, return_options)
    
    return combinations

# Calculation generated by Grok AI:
def create_flight_combinations(outbound_options, return_options):
    """Create flight combinations and sort by price."""
    combinations = []
    
    for out_opt in outbound_options:
        for ret_opt in return_options:
            total_fare = out_opt['price']['fare'] + ret_opt['price']['fare']
            total_fee = out_opt['price']['fee'] + ret_opt['price']['fee']
            total_price = out_opt['price']['total'] + ret_opt['price']['total']
            
            combinations.append({
                'outbound': out_opt,
                'return': ret_opt,
                'combined_price': {
                    'fare': total_fare, 
                    'fee': total_fee, 
                    'total': total_price
                }
            })

    combinations.sort(key=lambda x: x['combined_price']['total'])
    return combinations


def build_response(origin_airport, dest_airport, combinations, departure_date_str, return_date_str):
    """Build the final JSON response."""
    return {
        'summary': {
            'outbound': create_flight_summary(
                origin_airport, dest_airport, departure_date_str
            ),
            'return': create_flight_summary(
                dest_airport, origin_airport, return_date_str
            )
        },
        'combinations': combinations
    }


def create_flight_summary(from_airport, to_airport, departure_date):
    """Create flight summary for response."""
    return {
        'departure_date': departure_date,
        'from': airport_to_dict(from_airport),
        'to': airport_to_dict(to_airport),
        'currency': 'BRL'
    }


def airport_to_dict(airport):
    """Convert Airport instance to dictionary."""
    return {
        'iata': airport.iata,
        'city': airport.city,
        'state': airport.state,
        'lat': float(airport.lat),
        'lon': float(airport.lon)
    }


def process_flight_options(options, distance):
    """Process flight options with price and meta calculations."""
    for option in options:
        dep_time = datetime.fromisoformat(option['departure_time'])
        arr_time = datetime.fromisoformat(option['arrival_time'])
        duration_hours = (arr_time - dep_time).total_seconds() / 3600
        
        fare = option['price']['fare']
        fee = max(0.1 * fare, 40.0)
        total = fare + fee
        
        option['price'] = {'fare': fare, 'fee': fee, 'total': total}
        
        cruise_speed = round(distance / duration_hours) if duration_hours > 0 else 0
        cost_per_km = round(fare / distance, 2) if distance > 0 else 0.0
        
        option['meta'] = {
            'range': round(distance), 
            'cruise_speed_kmh': cruise_speed, 
            'cost_per_km': cost_per_km
        }

# Haversine calculation generated by Grok AI:
def haversine(lat1, lon1, lat2, lon2):
    """Calculate distance between two points using Haversine formula."""
    R = 6371  # Earth radius in km
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (math.sin(dlat/2)**2 + 
         math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    return R * c


def call_mock_api(from_iata: str, to_iata: str, departure_date_str: str) -> dict:
    """Call the mock flights API using credentials from Django settings."""
    required_settings = ['FLIGHTS_API_URL', 'API_LOGIN', 'API_PASSWORD', 'API_KEY']
    missing = [s for s in required_settings if not getattr(settings, s, None)]
    if missing:
        raise ValueError(f"Missing required settings: {', '.join(missing)}")
    
    try:
        endpoint = f"{settings.FLIGHTS_API_URL.rstrip('/')}/{settings.API_KEY}/{from_iata}/{to_iata}/{departure_date_str}"
        
        # Prepare authentication
        auth_string = f"{settings.API_LOGIN}:{settings.API_PASSWORD}"
        auth_token = base64.b64encode(auth_string.encode('utf-8')).decode('utf-8')
        
        headers = {
            'Authorization': f'Basic {auth_token}',
            'Content-Type': 'application/json'
        }
        
        req = urllib.request.Request(endpoint, headers=headers)
        
        with urllib.request.urlopen(req) as response:
            if response.status != 200:
                logger.error(f"API returned status {response.status}")
                raise urllib.error.URLError(f"API error: {response.status}")
                
            return json.loads(response.read().decode('utf-8'))
            
    except (json.JSONDecodeError, urllib.error.URLError) as e:
        logger.error(f"API request failed: {str(e)}")
        raise